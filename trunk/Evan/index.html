<html> 
 
<head> 
<title>Evan Pittfield - Homework 4</title> 
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1"> 
 
<script type="text/javascript" src="sylvester.js"></script> 
<script type="text/javascript" src="glUtils.js"></script> 
<script type="text/javascript" src="shaderUtils.js"></script>
<script type="text/javascript" src="keyboardInfo.js"></script>
<script type="text/javascript" src="artLoader.js"></script>
<script type="text/javascript" src="GameObject.js"></script>
<script type="text/javascript" src="HUD.js"></script>
<script type="text/javascript" src="Audio.js"></script>

<! HTML5 audio content>
<audio id="background" src="storm.wav" loop="true" autobuffer="autobuffer"></audio>




<script id="shader-fs" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	uniform mat4 uVMatrix;

	uniform vec3 lightPosition;
	uniform vec3 viewerPosition;

	uniform sampler2D uSamplerA;
	uniform sampler2D uSamplerB;
	uniform sampler2D uSamplerC;

	varying float vertexHeight;
	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec2 vTextureCoord;

	void main(void) 
	{
		//Texture
		vec4 textureColor;
		float range = vertexHeight / 4.0;

		//Select texture based on height
		if (range < 0.1)
		{
			textureColor = texture2D(uSamplerC, vTextureCoord);
		}
		else if (range < 0.5)
		{
			range -= 0.1;
			range *= 2.5;
			textureColor = range * texture2D(uSamplerB, vTextureCoord) + (1.0 - range) * texture2D(uSamplerC, vTextureCoord);
		}
		else if (range < 0.55)
		{
			textureColor = texture2D(uSamplerB, vTextureCoord);
		}
		else if (range < 0.95)
		{
			range -= 0.55;
			range *= 2.5;
			textureColor = range * texture2D(uSamplerA, vTextureCoord) + (1.0 - range) * texture2D(uSamplerB, vTextureCoord);
		}
		else
		{
			textureColor = texture2D(uSamplerA, vTextureCoord);
		}


		vec3 viewerVPosition = (uVMatrix * vec4(viewerPosition, 1.0)).xyz;

		//Lighting
		const float PI = 3.14159;
		const float shininess = 16.0;

		vec3 lightVector = normalize(lightPosition - vPosition.xyz);
		vec3 viewerVector = normalize(viewerVPosition - vPosition.xyz);

		vec3 normalVector = normalize(vTransformedNormal.xyz);
		vec3 halfVector = normalize(lightVector + viewerVector);

		vec3 specularColor = vec3(1.0, 1.0, 1.0);
		
		vec3 color0 = (vColor.rgb / PI) + ((shininess + 8.0) / (8.0 * PI)) * pow(max(dot(halfVector, normalVector), 0.0), shininess) * specularColor;
		vec3 other0 = vec3(1.0, 1.0, 1.0) * max(dot(lightVector, normalVector), 0.0);		

		color0.xyz *= other0;

		//Light on camera
		float distance = pow(pow(viewerVPosition.x - vPosition.x, 2.0) + pow(viewerVPosition.y - vPosition.y, 2.0) + pow(viewerVPosition.z - vPosition.z, 2.0),0.5);

		vec3 cameraLightVector = normalize(viewerVPosition - vPosition.xyz);
		vec3 cameraHalfVector = normalize(cameraLightVector + viewerVector);
		
		vec3 color1 = (vColor.rgb / PI) + ((shininess + 8.0) / (8.0 * PI)) * pow(max(dot(cameraHalfVector, normalVector), 0.0), shininess) * specularColor;
		vec3 other1 = vec3(1.0, 1.0, 1.0) * max(abs(dot(cameraLightVector, normalVector)), 0.0);

		if (distance > 15.0)
		{
			color1 *= max((30.0 - distance) / 15.0, 0.0);
		}

		color1 *= other1;
		

		//Final
		gl_FragColor = vec4((color0 + color1) * textureColor.rgb, vColor.a);
	}
</script>

 
<script id="shader-vs" type="x-shader/x-vertex"> 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
 
	uniform mat4 uVMatrix;
	uniform mat4 uMMatrix;
	uniform mat4 uPMatrix;
	uniform mat4 uNMatrix;

	varying float vertexHeight;
	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec2 vTextureCoord;

	void main(void) 
	{
		vColor = vec4(1.0, 1.0, 1.0, 1.0);

		vPosition = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;

		vTransformedNormal = uNMatrix * vec4(aVertexNormal, 1.0);

		vTextureCoord = aTextureCoord;

		vertexHeight = aVertexPosition.y;
	}
</script> 

<script id="shader-fs-standard" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	uniform mat4 uVMatrix;
	uniform mat4 uPMatrix;
	uniform vec3 lightPosition;
	uniform vec3 viewerPosition;
	
	//Flag to grab tonal shader as current shader
	uniform bool tonal;
	
	//Flag to grab toon shader as current shader
	uniform bool toon;
	
	//Type to represent the texture.
	uniform sampler2D uSampler;
	
	//Texture mapping units
	//Texture 1
	uniform sampler2D u_t1;
	
	//Texture 2
	uniform sampler2D u_t2;
	
	//Texture 3
	uniform sampler2D u_t3;
	
	//Texture 4
	uniform sampler2D u_t4;
	
	//Texture 5
	uniform sampler2D u_t5;
	
	//Texture 6
	uniform sampler2D u_t6;


	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec2 vTextureCoord;
	varying vec4 wPosition;

	void main(void) 
	{
		//Sample the texture		
		vec4 textureColor = texture2D(uSampler, vTextureCoord);	

		//Throw out invisible to ensure transparency
		if (textureColor.a < 0.01)
		{
			discard;
		}

		//Camera to view space
		vec3 viewerVPosition = (uVMatrix * vec4(viewerPosition, 1.0)).xyz;

		//Lighting
		const float shine = 16.0;
		const float PI = 3.14159;
		vec3 lightVector = normalize(lightPosition - vPosition.xyz);
		vec3 viewerVector = normalize(viewerVPosition - vPosition.xyz);
		vec3 normalVector = normalize(vTransformedNormal.xyz);
		vec3 halfVector = normalize(lightVector + viewerVector);
		vec3 specularColor = vec3(1.0, 1.0, 1.0);
		
		vec3 color0 = (vColor.rgb / PI) + (shine / PI) * pow(max(dot(halfVector, normalVector), 0.0), shine) * specularColor;
		vec3 other0 = vec3(1.0, 1.0, 1.0) * max(dot(lightVector, normalVector), 0.0);
		
		color0.xyz *= other0;

		//Light on camera
		float distance = pow(pow(viewerVPosition.x - vPosition.x, 2.0) + pow(viewerVPosition.y - vPosition.y, 2.0) + pow(viewerVPosition.z - vPosition.z, 2.0),0.5);

		vec3 cameraLightVector = normalize(viewerVPosition - vPosition.xyz);
		vec3 cameraHalfVector = normalize(cameraLightVector + viewerVector);
		
		vec3 color1 = (vColor.rgb / PI) + ((shine + 8.0) / (8.0 * PI)) * pow(max(dot(cameraHalfVector, normalVector), 0.0), shine) * specularColor;
		vec3 other1 = vec3(1.0, 1.0, 1.0) * max(abs(dot(cameraLightVector, normalVector)), 0.0);

		float visible = abs(dot(cameraLightVector, normalVector));

		if (distance > 15.0)
		{
			color1 *= max((30.0 - distance) / 15.0, 0.0);
		}

		color1 *= other1;
		
		//Tonal shading
		if (tonal)
		{
			//Clamping a vector to a minimum and maximum, due to lighting
			vec3 color = (color0 * other0 + color1 * other1) * textureColor.rgb;
			color.r = min(1.0, color.r);
			color.g = min(1.0, color.g);
			color.b = min(1.0, color.b);
 
 			//Get dot product
			float gray = dot(vec3(0.3, 0.59, 0.11), color);
 
 			//Set to white initially.
			vec4 tonalColor = vec4(1.0, 1.0, 1.0, 1.0);
 
 			//Force color through step function
			if (gray < 0.2)
			{
				gray *= 5.0;
				
				//Texture 5 and 6.
				tonalColor = gray * texture2D(u_t5, wPosition.zy) + (1.0 - gray) * texture2D(u_t6, wPosition.zy);
			}
			else if (gray < 0.4)
			{
				gray -= 0.2;
				gray *= 5.0;
				
				//Texture 4 and 5.
				tonalColor = gray * texture2D(u_t4, wPosition.zy) + (1.0 - gray) * texture2D(u_t5, wPosition.zy);
			}
			else if (gray < 0.6)
			{
				gray -= 0.4;
				gray *= 5.0;
				
				//Texture 3 and 4.
				tonalColor = gray * texture2D(u_t3, wPosition.zy) + (1.0 - gray) * texture2D(u_t4, wPosition.zy);
			}
			else if (gray < 0.8)
			{
				gray -= 0.6;
				gray *= 5.0;
				
				//Texture 2 and 3.
				tonalColor = gray * texture2D(u_t2, wPosition.zy) + (1.0 - gray) * texture2D(u_t3, wPosition.zy);
			}
			else if (gray <= 1.0)
			{
				gray -= 0.8;
				gray *= 5.0;
				
				//Texture 1 and 2.
				tonalColor = gray * texture2D(u_t1, wPosition.zy) + (1.0 - gray) * texture2D(u_t2, wPosition.zy);
			}
		
			//Set fragment color.
			gl_FragColor = vec4(tonalColor.r, tonalColor.g, tonalColor.b, textureColor.a);
		}
		
		//Normal shading if all else fails.
		else
		{
			gl_FragColor = vec4((color0 + color1) * textureColor.rgb, textureColor.a);
		}
	}
</script>

 
<script id="shader-vs-standard" type="x-shader/x-vertex"> 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
 
	uniform mat4 uVMatrix;
	uniform mat4 uMMatrix;
	uniform mat4 uPMatrix;
	uniform mat4 uNMatrix;

	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec2 vTextureCoord;
	varying vec4 wPosition;

	void main(void) 
	{
		vColor = vec4(1.0, 1.0, 1.0, 1.0);
		
		//Tonal art coords
		wPosition = vec4(aVertexPosition, 1.0) * vec4(uMMatrix[0][0], uMMatrix[1][1], uMMatrix[2][2], 1.0);

		vPosition = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		gl_Position = uPMatrix * vPosition;

		vTransformedNormal = uNMatrix * vec4(aVertexNormal, 1.0);

		vTextureCoord = aTextureCoord;
	}
</script> 

<script id="shader-fs-primitive" type="x-shader/x-fragment"> 
  #ifdef GL_ES
  precision highp float;
  #endif

  uniform vec3 uColor; 
 
  void main(void) {
    gl_FragColor = vec4(uColor, 1.0);
  }
</script> 
 
<script id="shader-vs-primitive" type="x-shader/x-vertex"> 
  attribute vec3 aVertexPosition;
 
  uniform mat4 uVMatrix;
  uniform mat4 uMMatrix;
  uniform mat4 uPMatrix;
  uniform mat4 uNMatrix;
  
  void main(void) {
    gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
  }
</script> 

<script id="shader-fs-skybox" type="x-shader/x-fragment">
	#ifdef GL_ES
	precision highp float;
	#endif

	uniform mat4 uVMatrix;

	uniform vec3 lightPosition;
	uniform vec3 viewerPosition;

	uniform samplerCube uSampler;

	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec3 vTextureCoord;

	void main(void) 
	{
		//Texture
		vec4 textureColor = textureCube(uSampler, vPosition.xyz);	

		//Camera to view space
		vec3 viewerVPosition = (uVMatrix * vec4(viewerPosition, 1.0)).xyz;

		//Lighting
		const float PI = 3.14159;
		const float shininess = 16.0;

		vec3 lightVector = normalize(lightPosition - vPosition.xyz);
		vec3 viewerVector = normalize(viewerVPosition - vPosition.xyz);

		vec3 normalVector = normalize(vTransformedNormal.xyz);
		vec3 halfVector = normalize(lightVector + viewerVector);

		vec3 specularColor = vec3(1.0, 1.0, 1.0);
		
		vec3 color0 = (vColor.rgb / PI) + ((shininess + 8.0) / (8.0 * PI)) * pow(max(dot(halfVector, normalVector), 0.0), shininess) * specularColor;
		vec3 other0 = vec3(1.0, 1.0, 1.0) * max(dot(lightVector, normalVector), 0.0);		

		color0.xyz *= other0;

		//Final
		gl_FragColor = vec4(color0 * textureColor.rgb, textureColor.a);
	}
</script>

 
<script id="shader-vs-skybox" type="x-shader/x-vertex"> 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
 
	uniform mat4 uVMatrix;
	uniform mat4 uMMatrix;
	uniform mat4 uPMatrix;
	uniform mat4 uNMatrix;

	varying vec4 vColor;
	varying vec4 vPosition;
	varying vec4 vTransformedNormal;
	varying vec3 vTextureCoord;

	void main(void) 
	{
		vColor = vec4(1.0, 1.0, 1.0, 1.0);

		vPosition = vec4(aVertexPosition, 1.0);

		gl_Position = uPMatrix * uVMatrix * uMMatrix * vPosition;

		vTransformedNormal = uNMatrix * vec4(aVertexNormal, 1.0);
	}
</script> 

<script id="shader-fs-depth" type="x-shader/x-fragment"> 
	#ifdef GL_ES
	precision highp float;
	#endif
 
	uniform mat4 uVMatrix;
	uniform mat4 uPMatrix;
 
	uniform sampler2D uSampler;
 
	varying float distance;
	varying vec2 vTextureCoord;
 
 
	void main(void) 
	{		
		//Texture
		vec4 textureColor = texture2D(uSampler, vTextureCoord);	
 
		//Throw out invisible to ensure transparency
		if (textureColor.a < 0.01)
		{
			discard;
		}
 
		gl_FragColor =  vec4(distance, distance, distance, 1.0);
	}
 
</script> 
 
<script id="shader-vs-depth" type="x-shader/x-vertex"> 
	attribute vec3 aVertexPosition;
	attribute vec3 aVertexNormal;
	attribute vec2 aTextureCoord;
 
	uniform vec3 lightPosition; 
 
	uniform mat4 uVMatrix;
	uniform mat4 uMMatrix;
	uniform mat4 uPMatrix;
	uniform mat4 uNMatrix;
 
	varying vec4 vTransformedNormal;
	varying vec2 vTextureCoord;
 
	varying float distance;
 
	void main(void) 
	{
 
		//For some reason it is complaining about this needing to be here....
		vTransformedNormal = vec4(aVertexNormal, 1.0);
 
		vTextureCoord = aTextureCoord;
 
		gl_Position = uPMatrix *  uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
		
		vec4 adjusted = uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
 
		distance = sqrt(pow(lightPosition.x - adjusted.x, 2.0) + pow(lightPosition.y - adjusted.y, 2.0) + pow(lightPosition.z - adjusted.z, 2.0)) / 550.0;
	}
</script> 

 
<script type="text/javascript">  

//Initialize gl
var gl;
function initGL(canvas) 
{
	try 
	{
		gl = canvas.getContext("experimental-webgl");
		gl.viewportWidth = canvas.width;
		gl.viewportHeight = canvas.height;

	} catch(e) {
	}
	if (!gl) 
	{
		alert("Could not initialise WebGL, sorry :-(");
	}
}
  
//Set vMatrix
var vMatrix;
function lookAt(cameraX, cameraY, cameraZ, centerX, centerY, centerZ, upX, upY, upZ)
{
	vMatrix = makeLookAt(cameraX, cameraY, cameraZ, centerX, centerY, centerZ, upX, upY, upZ);
} 

//Set pMatrix
var pMatrix;
function perspective(fovy, aspect, znear, zfar) 
{
	pMatrix = makePerspective(fovy, aspect, znear, zfar);
}  

//Variables
var MAX = 255;
var MIN = 0;
var lightPos = [25.0, 20.0, 25.0];					//Light position
var cameraPos = [0.0, 5.0, 0.0];					//Camera position
var characterHealth = 183;							//Character health
var enemyHealth = 200;								//Enemy Health
var level = 725;									//Level up exp
var grassTexture;									//Grass texture
var sandTexture;									//Sand texture
var stoneTexture;									//Stone texture
var waterTexture;									//Water texture
var beakerTexture;									//Red beaker texture
var pineTreeTexture;								//Pine tree texture
var copperTexture;									//Copper teapot texture
var coffeeTexture;									//Blue coffee cup texture
var vaseTexture;									//Green vase texture
var bulletTexture;									//Yellow bullet texture
var skyboxTexture;									//skybox texture
var terrain;										//Terrain texture
var impostors = Array();							//Tree impostors
var teapot;											//Teapot model
var coffeeCup;										//CoffeeCup model
var beaker;											//Beaker model
var skybox;											//Skybox model
var bullet;											//bullet model
var vaseVector = $V([1, 0, 1]);						//Direction vector for vase.
var coffeeCupVector = $V([1,0,1]);					//Direction vector for coffeeCup
var beakerVector = $V([1,0,1]);						//Direction vector for beaker
//var bulletVector = $V([1,0,1]);					//Slyvester Direction vector for bullet
var bulletVector = $V([1,0,1]);						//Slyvester Direction vector for bullet
var extras = Array();								//Extras
var yaw = 180;										//Camera rotations
var pitch = 0;										//Camera rotations
var shaderProgram;									//Pointer to shader program to run
var shaderProgramStandard;							//Default shader program
var primitiveProgram;								//Primitive shader
var skyboxProgram;									//Shader for skybox
var t1;												//Tonal texture 1.
var t2;												//Tonal texture 2.
var t3;												//Tonal texture 3.
var t4;												//Tonal texture 4.
var t5;												//Tonal texture 5.
var t6;												//Tonal texture 6.

//Shader bools, tested to draw
var tonalShade = false;

//Shader
var currentShader = shaderProgram;

//Draw scene
function drawScene() 
{
	gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
	//Set pMatrix
	perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 550.0);

	//Set vMatrix
	var teaCenter = teapot.box.getCenter().add(teapot.getPosition());
	lookAt(cameraPos[0], cameraPos[1], cameraPos[2], teaCenter.e(1), teaCenter.e(2), teaCenter.e(3), 0, 1, 0);	
	
	setGlobalUniforms(shaderProgram);
	setGlobalUniforms(shaderProgramStandard);
	setGlobalUniforms(primitiveProgram);
	setGlobalUniforms(skyboxProgram);
	setGlobalUniforms(depthProgram);


	//Draw objects
	//drawObject(skybox);
	//drawObject(teapot);
	drawObject(terrain);

	/*********************
	Randomly moving vase
	*********************/
	
	//Calculate new position
	/*var vasePosition = vase.getPosition();
	vasePosition = vasePosition.add(vaseVector);
	
	//Set x, and z, and clamp y to terrain.
	vasePosition.elements[0] = Math.max(0, Math.min(MAX, vasePosition.elements[0]));
	vasePosition.elements[2] = Math.max(0, Math.min(MAX, vasePosition.elements[2]));
	vasePosition.elements[1] = terrain.foo[3 * (Math.round(vasePosition.e(1)) * 256 + Math.round(vasePosition.e(3))) + 1]  + 0.1;
	
	//Update Position.
	vase.setPosition(vasePosition);*/
	drawObject(vase);
		
	/*********************
	Randomly moving coffee cup
	*********************/
	
	//Calculate new position
	/*var coffeeCupPosition = coffeeCup.getPosition();
	coffeeCupPosition = coffeeCupPosition.add(coffeeCupVector);
	
	//Set x, and z, and clamp y to terrain.
	coffeeCupPosition.elements[0] = Math.max(0, Math.min(MAX, coffeeCupPosition.elements[0]));
	coffeeCupPosition.elements[2] = Math.max(0, Math.min(MAX, coffeeCupPosition.elements[2]));
	coffeeCupPosition.elements[1] = terrain.foo[3 * (Math.round(coffeeCupPosition.e(1)) * 256 + Math.round(coffeeCupPosition.e(3))) + 1]  + 0.1;
	
	//Update Position.
	coffeeCup.setPosition(coffeeCupPosition);*/
	drawObject(coffeeCup);	
	
	/*********************
	Randomly moving coffee beaker
	*********************/
	
	//Calculate new position
	/*var beakerPosition = beaker.getPosition();
	beakerPosition = beakerPosition.add(beakerVector);
	
	//Set x, and z, and clamp y to terrain.
	beakerPosition.elements[0] = Math.max(0, Math.min(MAX, beakerPosition.elements[0]));
	beakerPosition.elements[2] = Math.max(0, Math.min(MAX, beakerPosition.elements[2]));
	beakerPosition.elements[1] = terrain.foo[3 * (Math.round(beakerPosition.e(1)) * 255 + Math.round(beakerPosition.e(3))) + 1]  + 0.6;
	
	//Update Position.
	beaker.setPosition(beakerPosition);*/
	drawObject(beaker);
		
	//AI
	//If any object hits the edge, change the direction every object will move towards.
	/*if (coffeeCupPosition.elements[0] == MAX || coffeeCupPosition.elements[0] == MIN 
	|| coffeeCupPosition.elements[2] == MAX || coffeeCupPosition.elements[2] == MIN
	|| vasePosition.elements[0] == MAX || vasePosition.elements[0] == MIN
	|| vasePosition.elements[2] == MAX || vasePosition.elements[2] == MIN
	|| beakerPosition.elements[0] == MAX || beakerPosition.elements[0] == MIN
	|| beakerPosition.elements[2] == MAX || beakerPosition.elements[2] == MIN)
	{
		coffeeCupVector.elements[0] = (Math.random() - 0.5) * .2;
		coffeeCupVector.elements[2] = (Math.random() - 0.5) * .2;
		vaseVector.elements[0] = (Math.random() - 0.5) * .2;
		vaseVector.elements[2] = (Math.random() - 0.5) * .2;
		beakerVector.elements[0] = (Math.random() - 0.5) * .2;
		beakerVector.elements[2] = (Math.random() - 0.5) * .2;
	}*/

	if(trueBullet == true)
	{
		var bulletPos = bullet.getPosition();
		bulletPos = bulletPos.add(bulletVector);
		bulletPos.elements[0] = Math.max(0, Math.min(MAX, bulletPos.elements[0]));	
		bulletPos.elements[2] = Math.max(0, Math.min(MAX, bulletPos.elements[2]));
		
		//If bullet goes out of bounds, reset bullet
		if (bulletPos.elements[0] == MAX || bulletPos.elements[0] == MIN || bulletPos.elements[2] == MAX || bulletPos.elements[2] == MIN)
		{
			trueBullet = false;
		}
		
		//Clamp bullet to terrain, make bullet dissapear before it goes through.
		//else if (bulletPos.elements[1] < terrain.foo[3 * (Math.round(bulletPos.e(1)) + Math.round(bulletPos.e(3)) * 256) + 1])
		else if(bulletPos.elements[1] < terrain.foo[3 * (Math.round(bulletPos.e(1)) * 255 + Math.round(bulletPos.e(3))) + 1]  + 0.6)
		{
			trueBullet = false;
		}
		
		//Nothing to check, then just update the bullet position.
		else
		{
			bullet.setPosition(bulletPos);
		}

		drawObject(bullet);
	}
	
	//Draw relative directional vector so bullet can point in right direction
	else
	{
		bulletPos = teaCenter;
		bullet.setPosition(bulletPos);
		bulletVector = $V([-Math.sin(Math.PI * yaw / 180.0), 0, -Math.cos(Math.PI * yaw / 180.0)]);	
		drawObject(bullet);
	}
	
	
	//Extra objects
	for (var i = 0; i < extras.length; i++)
	{
		drawObject(extras[i]);
	}

	//Must draw last due to transparency
	for (var i = 0; i < impostors.length; i++)
	{
		drawObject(impostors[i]);
	}

	//Bounding box
	//drawBoundingBox(teapot);
	drawBoundingBox(coffeeCup);
	drawBoundingBox(vase);
	drawBoundingBox(beaker);
	drawBoundingBox(bullet);
	ihope.draw();
}

//Generate trees in random places
function generateTrees()
{
	//var count = parseInt(document.getElementById("one").value);
	//var scale = parseFloat(document.getElementById("two").value);
	//var random = document.getElementById("scale").checked;
	
	var count = 100;
	var scale = 1;
	var random = scale;

	impostors.length = count;

	for (var i = 0; i < count; i++)
	{
		if (random)
		{
			var ran = Math.max(0.5, Math.random() * scale);
			impostors[i] = new Impostor(ran * 2, ran * 4);
		}
		else
		{
			impostors[i] = new Impostor(scale * 2, scale * 4);
		}
		
		var x = Math.floor(Math.random()*255);
		var z = Math.floor(Math.random()*255);

		impostors[i].setPosition($V([x, terrain.foo[3 * (x * 256 + z) + 1], z]));
		impostors[i].setTexture(0, pineTreeTexture);
	}
}

//Draw the bounding box for the object
function drawBoundingBox(object)
{
	gl.useProgram(primitiveProgram);

	gl.uniformMatrix4fv(primitiveProgram.pMatrixUniform, false, new Float32Array(pMatrix.flatten()));
	gl.uniformMatrix4fv(primitiveProgram.mMatrixUniform, false, new Float32Array(object.getMatrix().flatten()));
	gl.uniformMatrix4fv(primitiveProgram.vMatrixUniform, false, new Float32Array(vMatrix.flatten()));

	gl.uniform3f(primitiveProgram.colorUniform, 1.0, 1.0, 1.0);


	gl.bindBuffer(gl.ARRAY_BUFFER, object.box.vertexBuffer);
	gl.vertexAttribPointer(primitiveProgram.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.box.indexBuffer);
	gl.drawElements(gl.LINES, object.box.indexBuffer.size, gl.UNSIGNED_SHORT, object.box.indexBuffer);
}

//Draw the object
function drawObject(object)
{
	//If the object is enabled and is loaded
	if (!object.isEnabled() || !object.isLoaded())
	{
		return;
	}

	//Set up data based on object type
	switch(object.type)
	{
		case "heightmap":
		{
			currentShader = shaderProgram;
			gl.useProgram(currentShader);

			gl.enable(gl.DEPTH_TEST);
			gl.disable(gl.BLEND);
	
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(0));
			gl.uniform1i(shaderProgram.samplerUniformA, 0);

			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(1));
			gl.uniform1i(shaderProgram.samplerUniformB, 1);
	
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(2));
			gl.uniform1i(shaderProgram.samplerUniformC, 2);	

			break;
		}
		case "impostor":
		{
			currentShader = shaderProgramStandard;
			gl.useProgram(currentShader);

			gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.SRC_ALPHA, gl.ONE);
			gl.enable(gl.BLEND);

			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(0));
			gl.uniform1i(currentShader.samplerUniform, 0);

			break;
		}
		case "model":
		{
			currentShader = shaderProgramStandard;
			gl.useProgram(currentShader);
		
			break;
		}
		case "skybox":
		{
			gl.disable(gl.DEPTH_TEST);
			gl.disable(gl.BLEND);
			
			currentShader = skyboxProgram;
			gl.useProgram(currentShader);
			
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_CUBE_MAP, object.getTexture(0));
			gl.uniform1i(currentShader.samplerUniform, 0);

			break;
		}
		default:
		{

		}
	}

	//Need to investigate as this consumes roughly 15%
	gl.uniformMatrix4fv(currentShader.mMatrixUniform, false, new Float32Array(object.getMatrix().flatten()));

	//Only need to set the vertex info once if only index buffers change
	if (object.onlyIndicesChange())
	{
		if (object.hasVertexBuffer(0))
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, object.getVertexBuffer(0));
			gl.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
		}

		if (object.hasNormalBuffer(0))
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, object.getNormalBuffer(0));
			gl.vertexAttribPointer(currentShader.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
		}

		if (object.hasTextureCoordsBuffer(0))
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, object.getTextureCoordsBuffer(0));
			gl.vertexAttribPointer(currentShader.vertexTextureCoordsAttribute, 2, gl.FLOAT, false, 0, 0);
		}
	}

	//Go through each buffer
	for (var i = 0; i < object.numberOfBuffers; i++)
	{
		//Multiple index buffers using the same vertex information
		if (!object.onlyIndicesChange())
		{
			if (object.hasVertexBuffer(i))
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, object.getVertexBuffer(i));
				gl.vertexAttribPointer(currentShader.vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
			}

			if (object.hasNormalBuffer(i))
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, object.getNormalBuffer(i));
				gl.vertexAttribPointer(currentShader.vertexNormalAttribute, 3, gl.FLOAT, false, 0, 0);
			}
	
			if (object.hasTextureCoordsBuffer(i))
			{
				gl.bindBuffer(gl.ARRAY_BUFFER, object.getTextureCoordsBuffer(i));
				gl.vertexAttribPointer(currentShader.vertexTextureCoordsAttribute, 2, gl.FLOAT, false, 0, 0);
			}
		}
		
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, object.getTexture(i));
		gl.uniform1i(currentShader.samplerUniform, 0);
		
		//Hatch model
		if(object.type == "model")
		{
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(0));
			gl.uniform1i(currentShader.samplerUniform, 0);
			
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, t1);
			gl.uniform1i(shaderProgram.t1Uniform, 1);
 
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, t2);
			gl.uniform1i(shaderProgram.t2Uniform, 2);
 
			gl.activeTexture(gl.TEXTURE3);
			gl.bindTexture(gl.TEXTURE_2D, t3);
			gl.uniform1i(shaderProgram.t3Uniform, 3);
 
			gl.activeTexture(gl.TEXTURE4);
			gl.bindTexture(gl.TEXTURE_2D, t4);
			gl.uniform1i(shaderProgram.t4Uniform, 4);
 
			gl.activeTexture(gl.TEXTURE5);
			gl.bindTexture(gl.TEXTURE_2D, t5);
			gl.uniform1i(shaderProgram.t5Uniform, 5);
 
			gl.activeTexture(gl.TEXTURE6);
			gl.bindTexture(gl.TEXTURE_2D, t6);
			gl.uniform1i(shaderProgram.t6Uniform, 6);
		}
		
		//Hatch heightmap
		if(object.type == "heightmap" && tonalShade)
		{
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(0));
			gl.uniform1i(currentShader.samplerUniform, 0);
 
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, t3);
			gl.uniform1i(shaderProgram.t3Uniform, 3);
 
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, t5);
			gl.uniform1i(shaderProgram.t5Uniform, 5);
 		}
		
		if(object.type == "impostor" && tonalShade)
		{
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, object.getTexture(0));
			gl.uniform1i(currentShader.samplerUniform, 0);
			
			gl.activeTexture(gl.TEXTURE1);
			gl.bindTexture(gl.TEXTURE_2D, t4);
			gl.uniform1i(shaderProgram.t4Uniform, 4);
			
			gl.activeTexture(gl.TEXTURE2);
			gl.bindTexture(gl.TEXTURE_2D, t5);
			gl.uniform1i(shaderProgram.t5Uniform, 5);
		}
	
		//Index buffer or straight vertex	
		if (object.hasIndexBuffer(i))
		{
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, object.getIndexBuffer(i));	
			gl.drawElements(object.getDrawType(), object.getIndexBuffer(i).size, gl.UNSIGNED_SHORT, object.getIndexBuffer(i));
		}
		else
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, object.getVertexBuffer(i));
			gl.drawArrays(object.getDrawType(), 0, object.getVertexBuffer(i).size);
		}		
	}

	//Disable blending
	gl.disable(gl.BLEND);
}

//Called each iteration
function tick()
{
	//Handle input for the frame
	handleInput();

	//Adjust camera based on mouse input
	//yaw += mouseRotationY;
	//pitch += mouseRotationX;


	//Clamp yaw for my own sanity
	if (yaw > 360)
	{
		yaw -= 360;
	}	
	else if (yaw < 0)
	{
		yaw += 360;
	}

	//Cap pitch to avoid getting turned around
	pitch = Math.max(-80, Math.min(80, pitch));

	//Update the rotation of the teapot
	teapot.setYRotation(yaw - 270);

	//Set camera to be relative to teapot
	var teaCenter = teapot.box.getCenter().add(teapot.getPosition());
	var initialBullet = teapot.box.getCenter().add(teapot.getPosition());
	cameraPos[0] = teaCenter.e(1) + 10 * Math.sin(Math.PI * yaw / 180.0);
	cameraPos[1] = teaCenter.e(2) + pitch / 12.5;
	cameraPos[2] = teaCenter.e(3) + 10 * Math.cos(Math.PI * yaw / 180.0);

	//Draw
	drawScene();
}

function initTextures()
{
	//Will only load the first due to the texture cache
	for (var i = 0; i < 10; i++)
	{
		loadGLTexture("grass.png", true);
	}

	grassTexture = loadGLTexture("sand2.jpg", true);
	sandTexture = loadGLTexture("sand3.jpg", true);
	stoneTexture = loadGLTexture("sand1.jpg", true);
	waterTexture = loadGLTexture("water.png", true);
	pineTreeTexture = loadGLTexture("pinetree-scaled.png", false);
	copperTexture = loadGLTexture("copper.png", true);
	coffeeTexture = loadGLTexture("waterCoffee.png", true);
	vaseTexture = loadGLTexture("vasePicture.png", true);
	beakerTexture = loadGLTexture("red.png", true);
	bulletTexture = loadGLTexture("bulletpaint.png", true);
	
	t1 = loadGLTexture("1.png", true);
	t2 = loadGLTexture("2.png", true);
	t3 = loadGLTexture("3.png", true);
	t4 = loadGLTexture("4.png", true);
	t5 = loadGLTexture("5.png", true);
	t6 = loadGLTexture("6.png", true);

	//skyboxTexture = loadCubeMap("default_skybox", "png");
}


//Initialize the application
function webGLStart()
{
	var canvas = document.getElementById("mainCanvas");
	initGL(canvas);
	initShaders();
	initTextures();
	//playMusic('background');

	//Load terrain
	terrain = new HeightmapTerrain("wikimap.png");
	terrain.setTexture(0, grassTexture);
	terrain.setTexture(1, sandTexture);
	terrain.setTexture(2, stoneTexture);
	
	//Load beaker
	beaker = new Model("vase2.obj");
	beaker.setScale(0.01);
	beaker.setTexture(0, beakerTexture);
	beaker.setPosition($V([30, 1, 30]));

	//Load teapot
	teapot = new Model("teapot.obj");
	teapot.setScale(0.1);
	teapot.setTexture(0, copperTexture);
	
	//Load vase
	vase = new Model("vase.obj");
	vase.setScale(0.1);
	vase.setTexture(0, vaseTexture);
	vase.setPosition($V([20, 1.5, 20]));
	
	//Load coffeeCup
	coffeeCup = new Model("cup.obj");
	coffeeCup.setScale(0.1);
	coffeeCup.setTexture(0, coffeeTexture);
	coffeeCup.setPosition($V([10, 1, 10]));
	
	//Load bullet
	bullet = new Model("bulletpray.obj");
	bullet.setScale(0.01);
	bullet.setTexture(0, bulletTexture);

	//Load skybox
	/*skybox = new Skybox();
	skybox.setScale(200);
	skybox.setPosition($V([125, 0, 125]));
	skybox.setTexture(0, skyboxTexture);*/
	
	ihope = new HUD();
	
	gl.clearColor(0.1, 0.1, 0.1, 1.0);
 
	gl.clearDepth(1.0);
 
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);

	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);

	document.onkeydown = handleKeyDown;
	document.onkeyup = handleKeyUp; 

	setInterval(tick, 15);
} 

var ihope;
 
</script> 
 
</head> 
 

<body onload="webGLStart();"> 

<table>
<tr>
<td valign="top">
<canvas id="mainCanvas" style="border: none;" width="1024" height="768"></canvas>
<canvas id="headsUpDisplay" style="border: none;" width="1024" height="768"></canvas>

</td>
<td valign="top">
<b>Minimap</b><br>
<canvas id="imageCanvas" width="20" height="20"></canvas>
</td>
<td valign="top">
<div id="foo"></div>
<br>
<div id="bar"></div>
<br>
<div id="fubar"></div>
<br>
<td valign="top"> 
<b>Tree Generator</b><br> 
Trees: <input type="text" id="one" value="10" /> <br> 
Heights: <input type="text" id="two" value="1" /> <br> 
Vary heights: <input type="checkbox" id="scale" checked /> (Will go between 1 and the value in heights)<br/> 
<input type="button" value="Generate" onClick="generateTrees();" /> 
</td> 

</div>
</td>
</tr>
</table>

 
  <br/>  
 
 
</body> 
 
</html> 